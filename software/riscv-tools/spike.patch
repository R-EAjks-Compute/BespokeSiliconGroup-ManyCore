From 142da438504b145d5d54437e1c6877512424ad9a Mon Sep 17 00:00:00 2001
From: Bandhav Veluri <bandhav.veluri00@gmail.com>
Date: Mon, 3 Jun 2019 14:44:41 -0700
Subject: [PATCH] Hack to print a char by tohost write

---
 fesvr/device.h   | 1 +
 fesvr/syscall.cc | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/fesvr/device.h b/fesvr/device.h
index 1387b74..639b837 100644
--- a/fesvr/device.h
+++ b/fesvr/device.h
@@ -1,18 +1,19 @@
 #ifndef _DEVICE_H
 #define _DEVICE_H
 
 #include <vector>
 #include <queue>
 #include <cstring>
 #include <string>
 #include <functional>
+#include <cstdint>
 
 class memif_t;
 
 class command_t
 {
  public:
   typedef std::function<void(uint64_t)> callback_t;
   command_t(memif_t& memif, uint64_t tohost, callback_t cb)
     : _memif(memif), tohost(tohost), cb(cb) {}
 
diff --git a/fesvr/syscall.cc b/fesvr/syscall.cc
index ab7fc3b..750f090 100644
--- a/fesvr/syscall.cc
+++ b/fesvr/syscall.cc
@@ -193,20 +193,23 @@ std::string syscall_t::undo_chroot(const char* fn)
 
 void syscall_t::handle_syscall(command_t cmd)
 {
   if (cmd.payload() & 1) // test pass/fail
   {
     htif->exitcode = cmd.payload();
     if (htif->exit_code())
       std::cerr << "*** FAILED *** (tohost = " << htif->exit_code() << ")" << std::endl;
     return;
   }
+  else if (cmd.payload() & 0x2){
+      std::cout << char(cmd.payload() >> 8);
+  }
   else // proxied system call
     dispatch(cmd.payload());
 
   cmd.respond(1);
 }
 
 reg_t syscall_t::sys_exit(reg_t code, reg_t a1, reg_t a2, reg_t a3, reg_t a4, reg_t a5, reg_t a6)
 {
   htif->exitcode = code << 1 | 1;
   return 0;
-- 
2.18.4

